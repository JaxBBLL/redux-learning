# 现有技术

Redux拥有复杂的传统。它类似于某些模式和技术，但在重要方面也与它们不同。我们将探讨下面的一些相似之处和不同之处。

## Flux

Redux的灵感来自于Flux的几个重要特质。与Flux一样，Redux规定您将模型更新逻辑集中在应用程序的某个层中（在Flux中“存储”，在Redux中使用“reducers”）。它们不是让应用程序代码直接改变数据，而是告诉您将每个变异描述为一个称为“动作”的普通对象。

与Flux不同，**Redux没有Dispatcher的概念**。这是因为它依赖于纯函数而不是事件发射器，纯函数易于组合，不需要额外的实体来管理它们。根据您查看Flux的方式，您可能会将其视为偏差或实施细节。Flux经常被描述为（状态，动作）=>状态。从这个意义上说，Redux忠实于Flux架构，但由于纯粹的功能，它变得更简单。

与Flux的另一个重要区别是**Redux假设您从不改变您的数据**。您可以为您的状态使用普通对象和数组，但强烈建议不要在reducers中对它们进行变更。您应该始终返回一个新对象，对象扩展运算符提议或者像Immutable这样的库很容易。

虽然技术上可以编写不正确的减速器来改变性能极端情况的数据，但我们会积极阻止您这样做。时间旅行，录制/重播或热重新加载等开发功能将会中断。此外，似乎不变性在大多数真实应用程序中都会造成性能问题，因为，正如Om所说，即使你失去了对象分配，你仍然可以通过避免昂贵的重新渲染和重新计算而获胜，因为你知道由于减速器的纯度而改变了什么。

对于它的价值，Flux的创作者赞成Redux。